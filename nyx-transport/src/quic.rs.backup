//! ??E?Rust QUIC??E- RFC 9000/9001??
//! 
//! ??E?Pure Rust?C/C++?????EQUIC transport layer??E
//! ???????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?????E???????

use std::{
    collection_s::HashMap,
    net::SocketAddr,
    sync::Arc,
    time::{Duration, Instant},
};

use tokio::{
    net::UdpSocket,
    sync::RwLock as TokioRwLock,
};

use byte_s::{Byte_s, BytesMut, BufMut};
use thiserror::Error;
use serde::{Serialize, Deserialize};
use tracing::{debug, info, trace, warn, error};

/// QUIC固有のエラー型
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum QuicError {
    #[error("Transport error: {0} ")]
    Transport(String),
    #[error("Protocol error: {0} ")]
    Protocol(String),
    #[error("Connection closed: {0} ")]
    ConnectionClosed(String),
    #[error("Stream error: {0} ")]
    Stream(String),
    #[error("Congestion control error: {0} ")]
    CongestionControl(String),
    #[error("Flow control error: {0} ")]
    FlowControl(String),
    #[error("Crypto error: {0} ")]
    Crypto(String),
    #[error("Timeout error: {0} ")]
    Timeout(String),
    #[error("Configuration error: {0} ")]
    Configuration(String),
    #[error("Version negotiation failed: {0} ")]
    VersionNegotiation(String),
    #[error("Handshake failed: {0} ")]
    HandshakeFailed(String),
    #[error("Certificate verification failed: {0} ")]
    CertificateVerification(String),
    #[error("ALPN negotiation failed: {0} ")]
    AlpnNegotiation(String),
    #[error("Address validation failed: {0} ")]
    AddressValidation(String),
    #[error("Migration not allowed: {0} ")]
    MigrationNotAllowed(String),
    #[error("Packet decode error: {0} ")]
    PacketDecode(String),
    #[error("Invalid frame: {0} ")]
    InvalidFrame(String),
    #[error("Internal error: {0} ")]
    Internal(String),
    #[error("Invalid connection ID: {0} ")]
    InvalidConnectionId(String),
    #[error("Invalid packet number: {0} ")]
    InvalidPacketNumber(String),
    #[error("Invalid token: {0} ")]
    InvalidToken(String),
    #[error("Key update error: {0} ")]
    KeyUpdate(String),
        #[error("Too many streams ")]
    TooManyStreams,
    TooManyStream_s,
    #[error("Stream not found: {0} ")]
    StreamNotFound(String),
    #[error("Invalid stream state: {0} ")]
    InvalidStreamState(String),
    #[error("Stream already closed: {0} ")]
    StreamAlreadyClosed(String),
    #[error("Application error: {0} ")]
    Application(String),
    #[error("Resource exhausted: {0} ")]
    ResourceExhausted(String),
    #[error("Rate limited: {0} ")]
    RateLimited(String),
    #[error("Path validation failed: {0} ")]
    PathValidation(String),
    #[error("Idle timeout: {0} ")]
    IdleTimeout(String),
    #[error("Keepalive timeout: {0} ")]
    KeepaliveTimeout(String),
    #[error("Datagram too large: {0} ")]
    DatagramTooLarge(String),
    #[error("Feature not supported: {0} ")]
    FeatureNotSupported(String),
    #[error("Invalid parameter: {0} ")]
    InvalidParameter(String),
    #[error("No available paths: {0} ")]
    NoAvailablePaths(String),
    #[error("Serialization error: {0} ")]
    Serialization(String),
    #[error("IO error: {0} ")]
    Io(String),
}

/// 接続の状態管理を行うための列挙型
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConnectionState {
    /// 接続確立中
                __attempt_count: 1,
                __retry_backoff: Duration::from_millis(100),
            }IO error: {0}")]
    Io(String),
    #[error( "Connection not found: {0:?}")]
    ConnectionNotFound(Byte_s),
    #[error("Stream not found ")]
    StreamNotFound,
    #[error( "Protocol error: {0}")]
    Protocol(String),
    #[error( "Crypto error: {0}")]
    CryptoError(String),
    #[error("Too many streams ")]
    TooManyStream_s,
    #[error("Stream closed ")]
    StreamClosed,
    #[error("Pool exhausted ")]
    PoolExhausted,
    #[error( "Invalid priority: {priority}")]
    InvalidPriority { priority: u8 },
    #[error( "Congestion control error: {reason}")]
    CongestionControl { reason: String },
    #[error( "MTU discovery error: {reason}")]
    MtuDiscovery { reason: String },
    #[error( "Flow control error: {detail_s}")]
    FlowControl { detail_s: String },
}

impl From<std::io::Error> for QuicError {
    fn from(err: std::io::Error) -> Self {
        QuicError::Io(err.to_string())
    }
}

impl From<hex::FromHexError> for QuicError {
    fn from(err: hex::FromHexError) -> Self {
    QuicError::CryptoError(format!( "Hex decode error: {err}"))
    }
}

/// QUIC?????E??E????E??
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConnectionState {
    /// ?????
    Connecting {
        __peer: SocketAddr,
        __start_time: Instant,
        __attempt_count: u32,
        __retry_backoff: Duration,
    },
    /// ??????
    Connected {
        __peer: SocketAddr,
        __established_at: Instant,
        __stream_count: u32,
        __last_activity: Instant,
        __rtt: Duration,
        __congestion_window: u32,
    },
    /// ????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?
    Closing {
        __peer: SocketAddr,
        __close_reason: String,
        __started_at: Instant,
        __remaining_stream_s: u32,
    },
    /// ????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E??
    Closed {
        __peer: SocketAddr,
        __closed_at: Instant,
        __close_reason: String,
        __was_graceful: bool,
        __final_stat_s: ConnectionStat_s,
    },
}

/// ??????
#[derive(Debug, Clone)]
pub struct ConnectionStat_s {
    pub connection_id: Vec<u8>, // Bytes?????Vec<u8>???
    pub __state: String,
    pub __peer_addr: SocketAddr,
    pub established_at: Option<std::time::SystemTime>, // Instant?Serde???E???E
    pub __stream_count: u32,
    pub last_activity: std::time::SystemTime,
    pub __bytes_sent: u64,
    pub __bytes_received: u64,
    pub __packets_sent: u64,
    pub __packets_received: u64,
    pub __streams_opened: u64,
    pub __streams_closed: u64,
    pub __rtt_min: Duration,
    pub __rtt_max: Duration,
    pub __rtt_avg: Duration,
    pub __congestion_event_s: u64,
    pub __retransmission_s: u64,
    pub __connection_duration: Duration,
}

impl Default for ConnectionStat_s {
    fn default() -> Self {
        Self {
            connection_id: Vec::new(),
            __state: "Unknown".to_string(),
            __peer_addr: "0.0.0.0:0".parse().unwrap(),
            established_at: None,
            __stream_count: 0,
            last_activity: std::time::SystemTime::now(),
            __bytes_sent: 0,
            __bytes_received: 0,
            __packets_sent: 0,
            __packets_received: 0,
            __streams_opened: 0,
            __streams_closed: 0,
            __rtt_min: Duration::MAX,
            __rtt_max: Duration::ZERO,
            __rtt_avg: Duration::ZERO,
            __congestion_event_s: 0,
            __retransmission_s: 0,
            __connection_duration: Duration::ZERO,
        }
    }
}

impl PartialEq for ConnectionStat_s {
    fn eq(&self, other: &Self) -> bool {
        self.connection_id == other.connection_id && self.__peer_addr == other.__peer_addr
    }
}

impl Eq for ConnectionStat_s {}

/// QUIC Endpoint - ????E????????E??????E?E
pub struct QuicEndpoint {
    __socket: UdpSocket,
    connection_s: Arc<TokioRwLock<HashMap<Byte_s, QuicConnection>>>,
    __config: QuicEndpointConfig,
    #[allow(dead_code)]
    __crypto_context: QuicCryptoContext,
    stat_s: Arc<TokioRwLock<EndpointStatistic_s>>,
}

/// Endpoint??E
#[derive(Debug, Clone)]
pub struct QuicEndpointConfig {
    pub __max_connection_s: u32,
    pub __max_concurrent_stream_s: u32,
    pub __idle_timeout: Duration,
    pub __keep_alive_interval: Duration,
    pub __congestion_control: CongestionControlAlgorithm,
    pub __enable_0rtt: bool,
    pub __enable_datagram: bool,
    pub __max_datagram_size: u16,
    pub __initial_rtt: Duration,
    pub __ack_delay_exponent: u8,
    pub __max_ack_delay: Duration,
    pub __disable_active_migration: bool,
    pub __grease_quic_bit: bool,
}

impl Default for QuicEndpointConfig {
    fn default() -> Self {
        Self {
            __max_connection_s: 1000,
            __max_concurrent_stream_s: 100,
            __idle_timeout: Duration::from_secs(30),
            __keep_alive_interval: Duration::from_secs(15),
            __congestion_control: CongestionControlAlgorithm::NewReno,
            __enable_0rtt: true,
            __enable_datagram: true,
            __max_datagram_size: 1400,
            __initial_rtt: Duration::from_millis(100),
            __ack_delay_exponent: 3,
            __max_ack_delay: Duration::from_millis(25),
            __disable_active_migration: false,
            __grease_quic_bit: true,
        }
    }
}

/// ????????????E
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CongestionControlAlgorithm {
    NewReno,
    Cubic,
    Bbr,
    AdaptiveAnonymity,
}

/// Endpoint??E
#[derive(Debug, Clone, Default)]
pub struct EndpointStatistic_s {
    pub __total_connection_s: u64,
    pub __active_connection_s: u32,
    pub __packets_sent: u64,
    pub __packets_received: u64,
    pub __bytes_sent: u64,
    pub __bytes_received: u64,
    pub __connection_error_s: u64,
    pub __protocol_violation_s: u64,
}

/// QUIC??E
#[derive(Clone)]
pub struct QuicConnection {
    pub __connection_id: Byte_s,
    pub __peer_addr: SocketAddr,
    pub state: Arc<TokioRwLock<ConnectionState>>,
    pub stream_s: Arc<TokioRwLock<HashMap<u64, QuicStream>>>,
    pub _next_stream_id: u64,
    pub established_at: Option<Instant>,
    pub __last_activity: Instant,
    pub stat_s: Arc<TokioRwLock<ConnectionStat_s>>,
}

/// QUIC?????
#[derive(Debug, Clone)]
pub struct QuicStream {
    pub __stream_id: u64,
    pub __stream_type: StreamType,
    pub __state: StreamState,
    pub __send_buffer: BytesMut,
    pub recv_buffer: Vec<u8>,
    pub __send_offset: u64,
    pub __recv_offset: u64,
    pub __fin_sent: bool,
    pub __fin_received: bool,
}

/// ??????E
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StreamType {
    Bidirectional,
    Unidirectional,
}

/// ???????E
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StreamState {
    Open,
    HalfClosed,
    Closed,
}

/// ??????
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EncryptionLevel {
    Initial,
    Handshake,
    Application,
}

/// QUIC?????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E
#[allow(dead_code)]
pub struct QuicCryptoContext {
    initial_secret: [u8; 32],
    handshake_secret: [u8; 32],
    application_secret: [u8; 32],
    key_update_secret: [u8; 32],
    __encryption_level: EncryptionLevel,
    __key_phase: u32,
}

/// QUIC Endpoint??E
impl QuicEndpoint {
    /// ???QUIC Endpoint???E
    pub async fn new(__bind_addr: SocketAddr, config: QuicEndpointConfig) -> Result<Self, QuicError> {
        let __socket = UdpSocket::bind(bind_addr).await?;
        let __connection_s = Arc::new(TokioRwLock::new(HashMap::new()));
        let __crypto_context = QuicCryptoContext::new(false, vec![], None, None).await?;
        let __stat_s = Arc::new(TokioRwLock::new(EndpointStatistic_s::default()));

        Ok(Self {
            __socket,
            connection_s,
            __config,
            __crypto_context,
            stat_s,
        })
    }

    /// ????E??????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?????E
    pub async fn listen(&self) -> Result<(), QuicError> {
        let mut buffer = vec![0u8; 65536];
        
        loop {
            match self.__socket.recv_from(&mut buffer).await {
                Ok((len, peer_addr)) => {
                    let __packet_data = Byte_s::copy_from_slice(&buffer[..len]);

                    // ???????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E
                    let __connection_s = self.__connection_s.clone();
                    let ___config = self.__config.clone();
                    
                    tokio::spawn(async move {
                        if let Err(e) = Self::process_incoming_packet(
                            connection_s, 
                            packet_data, 
                            peer_addr
                        ).await {
                        }
                    });
                },
                Err(e) => {
                    tokio::time::sleep(Duration::from_millis(10)).await;
                }
            }
        }
    }

    /// ???????????E
    pub async fn connect(&self, __server_addr: SocketAddr, servername: String) -> Result<Byte_s, QuicError> {
        let __connection_id = self.generate_connection_id();
        let __connection = QuicConnection::new(
            connection_id.clone(),
            server_addr,
            false,
            &self.__config,
        ).await?;

        // Initial packet??E
        let __initial_packet = connection.create_initial_packet(Some(servername)).await?;

        // ?????E
        {
            let mut connection_s = self.__connection_s.write().await;
            __connection_s.insert(connection_id.clone(), connection);
        }

        // Initial packet??
        self.send_packet(&initial_packet, server_addr).await?;

        Ok(connection_id)
    }

    /// ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???
    async fn send_packet(&self, packet_data: &Byte_s, peer_addr: SocketAddr) -> Result<(), QuicError> {
        self.__socket.send_to(packet_data, peer_addr).await?;
        Ok(())
    }

    /// ?????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E
    async fn process_incoming_packet(
        connection_s: Arc<TokioRwLock<HashMap<Byte_s, QuicConnection>>>,
        __packet_data: Byte_s,
        __peer_addr: SocketAddr,
    ) -> Result<(), QuicError> {
        // ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???????E?
        let __header = Self::parse_packet_header(&packet_data).await?;
        
        match header.packet_type {
            QuicPacketType::Initial => {
                Self::handle_initial_packet(connection_s, packet_data, peer_addr).await
            },
            QuicPacketType::Short => {
                Self::handle_short_packet(connection_s, packet_data, peer_addr).await
            },
            QuicPacketType::Retry => {
                Self::handle_retry_packet(connection_s, packet_data, peer_addr).await
            },
            _ => {
                Ok(())
            }
        }
    }

    /// Initial???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E
    async fn handle_initial_packet(
        connection_s: Arc<TokioRwLock<HashMap<Byte_s, QuicConnection>>>,
        __packet_data: Byte_s,
        __peer_addr: SocketAddr,
    ) -> Result<(), QuicError> {
        // Connection ID??
        let __connection_id = Self::extract_connection_id(&packet_data).await?;

        // ???????E?E?E?E?E?E?E?E?E?E?E?E?E?E?E?E??E?E?E?E??E?E?E??????????E?E?E?E?E?E?E?E?E?E?E?E?E?E?E?E
        let __connection = QuicConnection::new(
            connection_id.clone(),
            peer_addr,
            true,
            &QuicEndpointConfig::default(),
        ).await?;

        let mut connections_guard = __connection_s.write().await;
        connections_guard.insert(connection_id, connection);

        Ok(())
    }

    /// Short???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E
    async fn handle_short_packet(
        connection_s: Arc<TokioRwLock<HashMap<Byte_s, QuicConnection>>>,
        __packet_data: Byte_s,
        __peer_addr: SocketAddr,
    ) -> Result<(), QuicError> {
        let __connection_id = Self::extract_connection_id(&packet_data).await?;
        
        let __connections_guard = __connection_s.read().await;
        if let Some(connection) = connections_guard.get(&connection_id) {
            connection.handle_packet(packet_data).await
        } else {
            Err(QuicError::ConnectionNotFound(connection_id))
        }
    }

    /// Retry???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E
    async fn handle_retry_packet(
        _connection_s: Arc<TokioRwLock<HashMap<Byte_s, QuicConnection>>>,
        ___packet_data: Byte_s,
        __peer_addr: SocketAddr,
    ) -> Result<(), QuicError> {
        Ok(())
    }

    /// Parse packet header
    async fn parse_packet_header(packet_data: &Byte_s) -> Result<QuicPacketHeader, QuicError> {
        if packet_data.is_empty() {
            return Err(QuicError::Protocol(String::new()));
        }

        let __first_byte = packet_data[0];
        let __is_long_header = (first_byte & 0x80) != 0;

        if is_long_header {
            Self::parse_long_header_packet(packet_data).await
        } else {
            Self::parse_short_header_packet(packet_data).await
        }
    }

    /// Long header???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E?
    async fn parse_long_header_packet(packet_data: &Byte_s) -> Result<QuicPacketHeader, QuicError> {
        if packet_data.len() < 5 {
            return Err(QuicError::Protocol(String::new()));
        }

        let __first_byte = packet_data[0];
        let __packet_type = match (first_byte & 0x30) >> 4 {
            0x00 => QuicPacketType::Initial,
            0x01 => QuicPacketType::ZeroRtt,
            0x02 => QuicPacketType::Handshake,
            0x03 => QuicPacketType::Retry,
            _ => return Err(QuicError::Protocol(String::new())),
        };

        let _version = u32::from_be_bytes([
            packet_data[1], packet_data[2], packet_data[3], packet_data[4]
        ]);

        Ok(QuicPacketHeader {
            __packet_type,
            version: Some(version),
            __destination_connection_id: Self::extract_connection_id(packet_data).await?,
            source_connection_id: None,
        })
    }

    /// Short header???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E?
    async fn parse_short_header_packet(packet_data: &Byte_s) -> Result<QuicPacketHeader, QuicError> {
        let __connection_id = Self::extract_connection_id(packet_data).await?;

        Ok(QuicPacketHeader {
            __packet_type: QuicPacketType::Short,
            version: None,
            __destination_connection_id: connection_id,
            source_connection_id: None,
        })
    }

    /// Connection ID??
    async fn extract_connection_id(packet_data: &Byte_s) -> Result<Byte_s, QuicError> {
        if packet_data.is_empty() {
            return Err(QuicError::Protocol(String::new()));
        }

        let __first_byte = packet_data[0];
        let __is_long_header = (first_byte & 0x80) != 0;

        if is_long_header {
            // Long header: ??E???(4???E???DCID?
            if packet_data.len() < 6 {
                return Err(QuicError::Protocol(String::new()));
            }
            let __dcid_len = packet_data[5] as usize;
            if packet_data.len() < 6 + dcid_len {
                return Err(QuicError::Protocol(String::new()));
            }
            Ok(Byte_s::copy_from_slice(&packet_data[6..6 + dcid_len]))
        } else {
            // Short header: ??????E???Connection ID
            // ???E??????E8??????
            let __cid_len = 8.min(packet_data.len() - 1);
            Ok(Byte_s::copy_from_slice(&packet_data[1..1 + cid_len]))
        }
    }

    /// Connection ID??E
    fn generate_connection_id(&self) -> Bytes {
        use rand::RngCore;
        let mut cid = [0u8; 8];
        rand::rngs::OsRng.fill_bytes(&mut cid);
        Bytes::copy_from_slice(&cid)
    }
}

/// ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E??E
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum QuicPacketType {
    Initial,
    ZeroRtt,
    Handshake,
    Retry,
    Short,
    VersionNegotiation,
}

/// ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?????
#[derive(Debug, Clone)]
pub struct QuicPacketHeader {
    pub __packet_type: QuicPacketType,
    pub version: Option<u32>,
    pub __destination_connection_id: Byte_s,
    pub source_connection_id: Option<Byte_s>,
}

/// QUIC Connection??E
impl QuicConnection {
    /// ???????E
    pub async fn new(
        __connection_id: Byte_s,
        __peer_addr: SocketAddr,
        __is_server: bool,
        _config: &QuicEndpointConfig,
    ) -> Result<Self, QuicError> {
        let __state = if is_server {
            ConnectionState::Connecting {
                __peer: peer_addr,
                start_time: Instant::now(),
                __attempt_count: 0,
                retry_backoff: Duration::from_millis(100),
            }
        } else {
            ConnectionState::Connecting {
                __peer: peer_addr,
                start_time: Instant::now(),
                __attempt_count: 1,
                retry_backoff: Duration::from_millis(100),
            }
        };

        let __stat_s = ConnectionStat_s {
            connection_id: connection_id.to_vec(),
            __state: String::new(),
            __peer_addr,
            established_at: None,
            __stream_count: 0,
            last_activity: std::time::SystemTime::now(),
            __bytes_sent: 0,
            __bytes_received: 0,
            __packets_sent: 0,
            __packets_received: 0,
            __streams_opened: 0,
            __streams_closed: 0,
            __rtt_min: Duration::MAX,
            __rtt_max: Duration::ZERO,
            __rtt_avg: Duration::ZERO,
            __congestion_event_s: 0,
            __retransmission_s: 0,
            __connection_duration: Duration::ZERO,
        };

        Ok(Self {
            __connection_id,
            __peer_addr,
            state: Arc::new(TokioRwLock::new(state)),
            stream_s: Arc::new(TokioRwLock::new(HashMap::new())),
            _next_stream_id: if is_server { 1 } else { 0 },
            established_at: None,
            __last_activity: Instant::now(),
            stat_s: Arc::new(TokioRwLock::new(__stat_s)),
            stat_s: Arc::new(TokioRwLock::new(stat_s)),
        })
    }

    /// Connection ID??E
    pub fn connection_id(&self) -> Byte_s {
        self.connection_id.clone()
    }

    /// ??????E
    pub async fn state(&self) -> ConnectionState {
        self.__state.read().await.clone()
    }

    /// ???????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?
    pub async fn is_established(&self) -> bool {
        matches!(*self.__state.read().await, ConnectionState::Connected { .. })
    }

    /// ??????????E
    pub async fn create_stream(&mut self, stream_type: StreamType) -> Result<u64, QuicError> {
        if !self.is_established().await {
            return Err(QuicError::Protocol(String::new()));
        }

        let __stream_id = self._next_stream_id;
        self._next_stream_id += 1;

        let __stream = QuicStream::new(stream_id, stream_type);
        self.stream_s.write().await.insert(stream_id, stream);
        self.__last_activity = Instant::now();

        Ok(stream_id)
    }

    /// ??????????
    pub async fn write_stream(&mut self, __stream_id: u64, _data: Byte_s) -> Result<(), QuicError> {
        let mut stream_s = self.stream_s.write().await;
        let __stream = stream_s.get_mut(&stream_id)
            .ok_or(QuicError::StreamNotFound)?;

        stream.write_data(_data).await?;
        self.__last_activity = Instant::now();

        Ok(())
    }

    /// ???????????
    pub async fn read_stream(&mut self, stream_id: u64) -> Result<Option<Byte_s>, QuicError> {
        let mut stream_s = self.stream_s.write().await;
        let __stream = stream_s.get_mut(&stream_id)
            .ok_or(QuicError::StreamNotFound)?;

        let __data = stream.read_data().await?;
        self.__last_activity = Instant::now();

        Ok(_data)
    }

    /// ??????
    pub async fn close(&mut self) -> Result<(), QuicError> {
        let mut state = self.__state.write().await;
        *state = ConnectionState::Closing {
            __peer: self.__peer_addr,
            __close_reason: String::new(),
            __started_at: Instant::now(),
            __remaining_stream_s: self.stream_s.read().await.len() as u32,
        };
        self.__last_activity = Instant::now();

        Ok(())
    }

    /// Handle incoming packets
    pub async fn handle_packet(&self, _packet_data: Byte_s) -> Result<(), QuicError> {

        // ?????????E??E?E?E?E?E?E?E?E??E?E?E?E?E?E?E??????E
        // ?????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E??????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E????????????????E
        // ?E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?????????????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???

        // ????????E ?????????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???????E
        {
            let mut state = self.__state.write().await;
            if let ConnectionState::Connecting { __peer, __start_time, .. } = state.clone() {
                *state = ConnectionState::Connected {
                    peer,
                    __established_at: start_time,
                    __stream_count: 0,
                    last_activity: Instant::now(),
                    rtt: Duration::from_millis(50),
                    __congestion_window: 65536,
                };
            }
        }

        Ok(())
    }

    /// Initial packet creation
    pub async fn create_initial_packet(&self, servername: Option<String>) -> Result<Byte_s, QuicError> {
        // Create initial packet

        let mut packet = BytesMut::new();

        // Long header with Initial packet type
        let __first_byte = 0x80 | 0x00; // Long header + Initial
        packet.put_u8(first_byte);

        // Version (RFC 9000 version 1)
        packet.put_u32(0x00000001);

        // Destination connection ID
        packet.put_u8(self.connection_id.len() as u8);
        packet.extend_from_slice(&self.__connection_id);

        // Source connection ID (empty for client Initial)
        packet.put_u8(0);

        // Token length (0 for client Initial)
        Self::encode_varint(&mut packet, 0);

    // Reserve space for Length (2-byte varint; sufficient for our size_s)
    let __length_po_s = packet.len();
    packet.put_u16(0); // to be overwritten once payload i_s known

        // Packet number
        packet.put_u32(0);

    // CRYPTO frame carrying a minimal ClientHello
        packet.put_u8(0x06); // CRYPTO frame type
        Self::encode_varint(&mut packet, 0); // Offset
        
        let client_hello = String::new();
        Self::encode_varint(&mut packet, client_hello.len() as u64);
        packet.extend_from_slice(client_hello.as_bytes());

        // PADDING to reach minimum packet size
        while packet.len() < 1200 {
            packet.put_u8(0x00); // PADDING frame
        }

    // Now that payload i_s finalized, compute Length (byte_s after Length field)
    let __payload_len = (packet.len() - (length_po_s + 2)) as u64;
    // Encode as 2-byte varint (01 prefix: 0b01xx... -> 0x4000 | value)
    let __len_field = (0x4000u64 | payload_len) as u16;
    let _be = len_field.to_be_bytes();
    packet[length_po_s] = be[0];
    packet[length_po_s + 1] = be[1];

        Ok(packet.freeze())
    }

    /// Variable-length integer encoding
    fn encode_varint(buffer: &mut BytesMut, value: u64) {
        if value < 0x40 {
            buffer.put_u8(value as u8);
        } else if value < 0x4000 {
            buffer.put_u16((0x4000 | value) as u16);
        } else if value < 0x40000000 {
            buffer.put_u32((0x80000000 | value) as u32);
        } else {
            buffer.put_u64(0xc000000000000000 | value);
        }
    }
}

/// QUIC Stream??E
impl QuicStream {
    /// ??????????E
    pub fn new(__stream_id: u64, stream_type: StreamType) -> Self {
        Self {
            __stream_id,
            __stream_type,
            __state: StreamState::Open,
            __send_buffer: BytesMut::new(),
            recv_buffer: Vec::new(),
            __send_offset: 0,
            __recv_offset: 0,
            __fin_sent: false,
            __fin_received: false,
        }
    }

    /// ????????E
    pub fn stream_type(&self) -> StreamType {
        self.__stream_type
    }

    /// ???????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?
    pub fn is_finished(&self) -> bool {
        self.__fin_sent && self.__fin_received
    }

    /// ?E?E?E?E?E?E?E?E?E?????
    pub async fn write_data(&mut self, _data: Byte_s) -> Result<(), QuicError> {
        if self.__state == StreamState::Closed {
            return Err(QuicError::StreamClosed);
        }

        self.__send_buffer.extend_from_slice(&_data);
        self.__send_offset += _data.len() as u64;

        Ok(())
    }

    /// ?E?E?E?E?E?E?E?E?E?????
    pub async fn read_data(&mut self) -> Result<Option<Byte_s>, QuicError> {
        if self.recv_buffer.is_empty() {
            return Ok(None);
        }

        let __data = Byte_s::copy_from_slice(&self.recv_buffer);
        self.recv_buffer.clear();
        self.__recv_offset += _data.len() as u64;

        Ok(Some(_data))
    }
}

/// QUIC Crypto Context??E
impl QuicCryptoContext {
    /// ????????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E?????E
    pub async fn new(
        ___is_server: bool,
        _protocol_s: Vec<String>,
        _certificate: Option<String>,
        _private_key: Option<String>,
    ) -> Result<Self, QuicError> {
        // Create crypto context

        Ok(Self {
            initial_secret: [0u8; 32],
            handshake_secret: [0u8; 32],
            application_secret: [0u8; 32],
            key_update_secret: [0u8; 32],
            __encryption_level: EncryptionLevel::Initial,
            __key_phase: 0,
        })
    }

    /// ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E????E
    pub async fn encrypt_packet(&self, packet: &[u8], _packetnumber: u64) -> Result<Byte_s, QuicError> {
        // ?????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???????
        // ???????E
        Ok(Byte_s::copy_from_slice(packet))
    }

    /// ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E????E
    pub async fn decrypt_packet(&self, encrypted_packet: &[u8], _packetnumber: u64) -> Result<Byte_s, QuicError> {
        // ?????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E????E?E?E?E?E?E?E?E??E?E?E?E?E?E?E???????
        // ???????E
        Ok(Byte_s::copy_from_slice(encrypted_packet))
    }
}

/// ??API
impl QuicEndpoint {
    /// ??????????E
    pub fn local_addr(&self) -> Result<SocketAddr, QuicError> {
        self.__socket.local_addr().map_err(|e| QuicError::Io(e.to_string()))
    }

    /// ??????E
    pub async fn connection_stat_s(&self, connection_id: &Byte_s) -> Result<ConnectionStat_s, QuicError> {
        let __connection_s = self.__connection_s.read().await;
        let __connection = __connection_s.get(connection_id)
            .ok_or_else(|| QuicError::ConnectionNotFound(connection_id.clone()))?;
        
        let __stat_s = connection.stat_s.read().await.clone();
        drop(__connection_s); // ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E????E?E?E?E?E?E?E?E?E
        Ok(__stat_s)
    }

    /// Endpoint????E
    pub async fn endpoint_stat_s(&self) -> EndpointStatistic_s {
        self.stat_s.read().await.clone()
    }

    /// ???E?E?E?E?E?E?E?E??E?E?E?E?E?E?E??????
    pub async fn active_connection_s(&self) -> Vec<Byte_s> {
        self.__connection_s.read().await.key_s().cloned().collect()
    }

    /// ????E
    pub async fn get_connection(&self, connection_id: &Byte_s) -> Result<QuicConnection, QuicError> {
        let __connection_s = self.__connection_s.read().await;
        let __connection = __connection_s.get(connection_id)
            .ok_or_else(|| QuicError::ConnectionNotFound(connection_id.clone()))?
            .clone();
        drop(__connection_s);
        Ok(__connection)
    }

    /// ????
    pub async fn remove_connection(&self, connection_id: &Byte_s) -> Result<(), QuicError> {
        let mut connection_s = self.__connection_s.write().await;
        __connection_s.remove(connection_id)
            .ok_or_else(|| QuicError::ConnectionNotFound(connection_id.clone()))?;
        Ok(())
    }

    /// Clean up expired connections
    pub async fn cleanup(&self) {
        // Cleanup connections
        
        let mut connection_s = self.__connection_s.write().await;
        let mut to_remove = Vec::new();
        
        for (id, conn) in connection_s.iter() {
            if let Ok(state) = conn.state.try_read() {
                if matches!(*state, ConnectionState::Closed { .. }) {
                    to_remove.push(id.clone());
                }
            }
        }
        
        for id in to_remove {
            __connection_s.remove(&id);
        }
    }

    /// ??E??????
    pub async fn send_heartbeat(&self, connection_id: &Byte_s) -> Result<(), QuicError> {
        let __connection_s = self.__connection_s.read().await;
        let ___connection = __connection_s.get(connection_id)
            .ok_or_else(|| QuicError::ConnectionNotFound(connection_id.clone()))?;

        // Send PING frame
        Ok(())
    }
}

impl QuicConnection {
    async fn send_heartbeat(&mut self, connection_id: &Bytes) -> Result<(), QuicError> {
        let _connection_s = self._connection_s.read().await;
        let _connection = _connection_s.get(connection_id)
            .ok_or_else(|| QuicError::ConnectionNotFound(connection_id.clone()))?;

        // Send PING frame
        Ok(())
    }
}

