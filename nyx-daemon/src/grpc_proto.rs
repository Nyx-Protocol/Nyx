//! gRPC Protocol Buffer Generated Code
//!
//! This module contains the Rust code generated from Protobuf definitions by tonic-build.
//! The code is generated at build time from `proto/control.proto`.
//!
//! # Architecture
//! - Pure Rust implementation (no C/C++ dependencies)
//! - Uses tonic for gRPC transport with rustls for TLS
//! - Provides both client and server traits for the NyxControl service
//!
//! # Generated Services
//! - `NyxControl`: Main control plane API for daemon management
//! - `SessionService`: Session lifecycle management
//!
//! # Usage
//! ```ignore
//! use nyx_daemon::grpc_proto::nyx_control_server::{NyxControl, NyxControlServer};
//! ```

#![allow(clippy::large_enum_variant)] // Generated protobuf code

// Include the generated protobuf code
// This is generated by tonic-build in build.rs from proto/control.proto
tonic::include_proto!("nyx.api");

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_creation() {
        // Test Empty message creation
        let _empty = Empty {};

        // Test Timestamp creation
        let timestamp = Timestamp {
            seconds: 1234567890,
            nanos: 123456789,
        };
        assert_eq!(timestamp.seconds, 1234567890);
        assert_eq!(timestamp.nanos, 123456789);
    }

    #[test]
    fn test_node_info_creation() {
        let node_info = NodeInfo {
            node_id: "test-node-1".to_string(),
            version: "0.1.0".to_string(),
            uptime_sec: 3600,
            bytes_in: 1024 * 1024,
            bytes_out: 2048 * 1024,
            pid: 12345,
            active_streams: 10,
            connected_peers: 5,
            mix_routes: vec!["route1".to_string(), "route2".to_string()],
            performance: None,
            resources: None,
            topology: None,
        };

        assert_eq!(node_info.node_id, "test-node-1");
        assert_eq!(node_info.version, "0.1.0");
        assert_eq!(node_info.uptime_sec, 3600);
    }

    #[test]
    fn test_stream_response_creation() {
        let response = StreamResponse {
            stream_id: 42,
            status: "open".to_string(),
            target_address: "127.0.0.1:8080".to_string(),
            initial_stats: None,
            success: true,
            message: "Stream opened successfully".to_string(),
        };

        assert_eq!(response.stream_id, 42);
        assert!(response.success);
    }

    #[test]
    fn test_health_response_creation() {
        let health = HealthResponse {
            status: "healthy".to_string(),
            checks: vec![],
            checked_at: Some(Timestamp {
                seconds: 1234567890,
                nanos: 0,
            }),
        };

        assert_eq!(health.status, "healthy");
        assert!(health.checks.is_empty());
    }

    #[test]
    fn test_session_status_creation() {
        let session = SessionStatusResponse {
            session_id: 1001,
            role: "client".to_string(),
            state: "established".to_string(),
            age_ms: 5000,
            idle_time_ms: 1000,
            has_traffic_keys: true,
            metrics: Some(SessionMetrics {
                bytes_tx: 1024,
                bytes_rx: 2048,
                frames_tx: 10,
                frames_rx: 15,
                handshake_duration_ms: Some(150),
                established_at_ms: Some(1234567890000),
            }),
        };

        assert_eq!(session.session_id, 1001);
        assert_eq!(session.role, "client");
        assert_eq!(session.state, "established");
        assert!(session.has_traffic_keys);
    }
}
