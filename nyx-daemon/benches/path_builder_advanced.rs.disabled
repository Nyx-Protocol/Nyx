//! Advanced Path Builder Performance Benchmarks
//! 
//! Comprehensive benchmarks for advanced path building algorithms
//! including multipath optimization, latency-aware routing, and
//! adaptive path selection under various network conditions.

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use nyx_daemon::path_builder::{PathBuilder, PathBuilderConfig, PathMetrics, PathSelection, NetworkCondition};
use std::time::Duration;
use std::collections::HashMap;

/// Mock network conditions for testing
#[derive(Debug, Clone)]
struct NetworkCondition {
    name: &'static str,
    latency_ms: u64,
    bandwidth_mbps: u64,
    packet_loss_percent: f64,
    jitter_ms: u64,
}

impl NetworkCondition {
    const EXCELLENT: NetworkCondition = NetworkCondition {
        name: "excellent",
        latency_ms: 10,
        bandwidth_mbps: 1000,
        packet_loss_percent: 0.01,
        jitter_ms: 1,
    };
    
    const GOOD: NetworkCondition = NetworkCondition {
        name: "good",
        latency_ms: 50,
        bandwidth_mbps: 100,
        packet_loss_percent: 0.1,
        jitter_ms: 5,
    };
    
    const AVERAGE: NetworkCondition = NetworkCondition {
        name: "average",
        latency_ms: 100,
        bandwidth_mbps: 25,
        packet_loss_percent: 0.5,
        jitter_ms: 20,
    };
    
    const POOR: NetworkCondition = NetworkCondition {
        name: "poor",
        latency_ms: 300,
        bandwidth_mbps: 5,
        packet_loss_percent: 2.0,
        jitter_ms: 100,
    };
    
    const MOBILE: NetworkCondition = NetworkCondition {
        name: "mobile",
        latency_ms: 150,
        bandwidth_mbps: 10,
        packet_loss_percent: 1.0,
        jitter_ms: 50,
    };
}

/// Benchmark basic path building operations
fn bench_basic_path_building(c: &mut Criterion) {
    let mut group = c.benchmark_group("basic_path_building");
    
    for node_count in [10, 50, 100, 500].iter() {
        group.bench_with_input(
            BenchmarkId::new("single_path", node_count),
            node_count,
            |b, &node_count| {
                let config = PathBuilderConfig::default();
                let builder = PathBuilder::new(config);
                let nodes = generate_mock_nodes(node_count);
                
                b.iter(|| {
                    let path = builder.build_single_path(&nodes, "source", "destination");
                    black_box(path);
                });
            }
        );
    }
    group.finish();
}

/// Benchmark multipath construction
fn bench_multipath_construction(c: &mut Criterion) {
    let mut group = c.benchmark_group("multipath_construction");
    
    for path_count in [2, 4, 8, 16].iter() {
        group.bench_with_input(
            BenchmarkId::new("multiple_paths", path_count),
            path_count,
            |b, &path_count| {
                let config = PathBuilderConfig {
                    max_paths: *path_count,
                    diversity_weight: 0.3,
                    latency_weight: 0.4,
                    bandwidth_weight: 0.3,
                    ..Default::default()
                };
                let builder = PathBuilder::new(config);
                let nodes = generate_mock_nodes(100);
                
                b.iter(|| {
                    let paths = builder.build_multiple_paths(&nodes, "source", "destination", *path_count);
                    black_box(paths);
                });
            }
        );
    }
    group.finish();
}

/// Benchmark adaptive path selection under different network conditions
fn bench_adaptive_path_selection(c: &mut Criterion) {
    let mut group = c.benchmark_group("adaptive_path_selection");
    
    let conditions = [
        NetworkCondition::EXCELLENT,
        NetworkCondition::GOOD, 
        NetworkCondition::AVERAGE,
        NetworkCondition::POOR,
        NetworkCondition::MOBILE,
    ];
    
    for condition in conditions.iter() {
        group.bench_with_input(
            BenchmarkId::new("adaptive_selection", condition.name),
            condition,
            |b, condition| {
                let config = PathBuilderConfig::adaptive_for_condition(condition);
                let builder = PathBuilder::new(config);
                let nodes = generate_nodes_with_condition(50, condition);
                
                b.iter(|| {
                    let selection = builder.select_optimal_path(&nodes, "source", "destination");
                    black_box(selection);
                });
            }
        );
    }
    group.finish();
}

/// Benchmark path quality scoring algorithms
fn bench_path_quality_scoring(c: &mut Criterion) {
    let mut group = c.benchmark_group("path_quality_scoring");
    
    let path_lengths = [3, 5, 10, 20];
    
    for &length in path_lengths.iter() {
        group.throughput(Throughput::Elements(length as u64));
        group.bench_with_input(
            BenchmarkId::new("quality_scoring", length),
            &length,
            |b, &length| {
                let builder = PathBuilder::new(PathBuilderConfig::default());
                let path = generate_mock_path(length);
                
                b.iter(|| {
                    let score = builder.calculate_path_quality(&path);
                    black_box(score);
                });
            }
        );
    }
    group.finish();
}

/// Benchmark real-time path adaptation
fn bench_realtime_adaptation(c: &mut Criterion) {
    c.bench_function("realtime_path_adaptation", |b| {
        let config = PathBuilderConfig::default();
        let mut builder = PathBuilder::new(config);
        let nodes = generate_mock_nodes(100);
        
        // Pre-build initial paths
        let initial_paths = builder.build_multiple_paths(&nodes, "source", "destination", 4);
        
        b.iter(|| {
            // Simulate changing network conditions
            let updated_metrics = generate_updated_metrics();
            
            // Adapt existing paths
            let adapted_paths = builder.adapt_paths(&initial_paths, &updated_metrics);
            black_box(adapted_paths);
        });
    });
}

/// Benchmark path caching and lookup performance
fn bench_path_caching(c: &mut Criterion) {
    let mut group = c.benchmark_group("path_caching");
    
    for cache_size in [100, 1000, 10000].iter() {
        group.bench_with_input(
            BenchmarkId::new("cache_lookup", cache_size),
            cache_size,
            |b, &cache_size| {
                let mut builder = PathBuilder::new(PathBuilderConfig::default());
                
                // Pre-populate cache
                for i in 0..*cache_size {
                    let source = format!("source_{}", i);
                    let dest = format!("dest_{}", i);
                    let path = generate_mock_path(5);
                    builder.cache_path(&source, &dest, path);
                }
                
                b.iter(|| {
                    let key = format!("source_{}", *cache_size / 2);
                    let dest = format!("dest_{}", *cache_size / 2);
                    let cached = builder.get_cached_path(&key, &dest);
                    black_box(cached);
                });
            }
        );
    }
    group.finish();
}

/// Benchmark concurrent path building
fn bench_concurrent_path_building(c: &mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    c.bench_function("concurrent_path_building_8_threads", |b| {
        b.to_async(&rt).iter(|| async {
            let config = PathBuilderConfig::default();
            let nodes = generate_mock_nodes(100);
            
            let mut handles = Vec::new();
            
            for i in 0..8 {
                let builder = PathBuilder::new(config.clone());
                let nodes = nodes.clone();
                
                let handle = tokio::spawn(async move {
                    let source = format!("source_{}", i);
                    let dest = format!("dest_{}", i);
                    builder.build_single_path(&nodes, &source, &dest)
                });
                
                handles.push(handle);
            }
            
            let results = futures::future::join_all(handles).await;
            black_box(results);
        });
    });
}

/// Helper functions for generating mock data

fn generate_mock_nodes(count: usize) -> Vec<MockNode> {
    (0..count).map(|i| MockNode {
        id: format!("node_{}", i),
        latency: Duration::from_millis(10 + (i as u64 % 100)),
        bandwidth: 100 + (i as u64 % 900),
        reliability: 0.95 + (i as f64 % 5) / 100.0,
    }).collect()
}

fn generate_nodes_with_condition(count: usize, condition: &NetworkCondition) -> Vec<MockNode> {
    (0..count).map(|i| MockNode {
        id: format!("node_{}", i),
        latency: Duration::from_millis(condition.latency_ms + (i as u64 % 20)),
        bandwidth: condition.bandwidth_mbps + (i as u64 % 20),
        reliability: 1.0 - (condition.packet_loss_percent / 100.0),
    }).collect()
}

fn generate_mock_path(length: usize) -> MockPath {
    MockPath {
        nodes: (0..length).map(|i| format!("node_{}", i)).collect(),
        total_latency: Duration::from_millis(length as u64 * 20),
        min_bandwidth: 100,
        avg_reliability: 0.95,
    }
}

fn generate_updated_metrics() -> HashMap<String, PathMetrics> {
    let mut metrics = HashMap::new();
    for i in 0..10 {
        metrics.insert(
            format!("node_{}", i),
            PathMetrics {
                latency: Duration::from_millis(50 + i * 10),
                bandwidth: 150 + i * 20,
                packet_loss: (i as f64) / 1000.0,
                jitter: Duration::from_millis(i * 2),
                last_updated: std::time::Instant::now(),
            }
        );
    }
    metrics
}

/// Mock data structures
#[derive(Debug, Clone)]
struct MockNode {
    id: String,
    latency: Duration,
    bandwidth: u64,
    reliability: f64,
}

impl nyx_daemon::path_builder::NetworkNode for MockNode {
    fn id(&self) -> &str {
        &self.id
    }
    
    fn latency(&self) -> Duration {
        self.latency
    }
    
    fn bandwidth(&self) -> u64 {
        self.bandwidth
    }
    
    fn reliability(&self) -> f64 {
        self.reliability
    }
}

#[derive(Debug, Clone)]
struct MockPath {
    nodes: Vec<String>,
    total_latency: Duration,
    min_bandwidth: u64,
    avg_reliability: f64,
}

criterion_group!(
    benches,
    bench_basic_path_building,
    bench_multipath_construction,
    bench_adaptive_path_selection,
    bench_path_quality_scoring,
    bench_realtime_adaptation,
    bench_path_caching,
    bench_concurrent_path_building
);

criterion_main!(benches);

