# ==================================================================================
# GitLab CI/CD - Deployment Configuration
# Automated deployment to staging and production environments
# ==================================================================================
#
# This configuration provides:
# - Multi-environment deployment (staging/production)
# - Kubernetes deployment with Helm
# - Docker image publishing
# - Automated rollback capabilities
# - Deployment verification
#
# ==================================================================================

variables:
  # Deployment configuration
  HELM_VERSION: "3.14.0"
  KUBECTL_VERSION: "1.29.0"
  DOCKER_REGISTRY: ${CI_REGISTRY}
  STAGING_NAMESPACE: nyx-staging
  PRODUCTION_NAMESPACE: nyx-production

# ==================================================================================
# Docker image building and publishing
# ==================================================================================

.docker_build_base:
  image: docker:24.0
  services:
    - docker:24.0-dind
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

# Build and push daemon image
docker:build-daemon:
  extends: .docker_build_base
  stage: package
  script:
    - echo "üê≥ Building nyx-daemon Docker image"
    - |
      docker build \
        -f nyx-daemon/Dockerfile \
        -t ${DOCKER_REGISTRY}/nyx-daemon:${CI_COMMIT_SHORT_SHA} \
        -t ${DOCKER_REGISTRY}/nyx-daemon:latest \
        --build-arg RUST_VERSION=1.77 \
        .
    - docker push ${DOCKER_REGISTRY}/nyx-daemon:${CI_COMMIT_SHORT_SHA}
    - docker push ${DOCKER_REGISTRY}/nyx-daemon:latest
    - echo "‚úÖ Daemon image published"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'
  tags:
    - docker

# Build and push CLI image
docker:build-cli:
  extends: .docker_build_base
  stage: package
  script:
    - echo "üê≥ Building nyx-cli Docker image"
    - |
      docker build \
        -f nyx-cli/Dockerfile \
        -t ${DOCKER_REGISTRY}/nyx-cli:${CI_COMMIT_SHORT_SHA} \
        -t ${DOCKER_REGISTRY}/nyx-cli:latest \
        --build-arg RUST_VERSION=1.77 \
        .
    - docker push ${DOCKER_REGISTRY}/nyx-cli:${CI_COMMIT_SHORT_SHA}
    - docker push ${DOCKER_REGISTRY}/nyx-cli:latest
    - echo "‚úÖ CLI image published"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'
  tags:
    - docker

# Build and push HTTP proxy image
docker:build-http-proxy:
  extends: .docker_build_base
  stage: package
  script:
    - echo "üê≥ Building nyx-http-proxy Docker image"
    - |
      docker build \
        -f nyx-http-proxy/Dockerfile \
        -t ${DOCKER_REGISTRY}/nyx-http-proxy:${CI_COMMIT_SHORT_SHA} \
        -t ${DOCKER_REGISTRY}/nyx-http-proxy:latest \
        --build-arg GO_VERSION=1.23 \
        .
    - docker push ${DOCKER_REGISTRY}/nyx-http-proxy:${CI_COMMIT_SHORT_SHA}
    - docker push ${DOCKER_REGISTRY}/nyx-http-proxy:latest
    - echo "‚úÖ HTTP proxy image published"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'
  tags:
    - docker

# ==================================================================================
# Helm chart packaging
# ==================================================================================

helm:package:
  image: alpine/helm:${HELM_VERSION}
  stage: package
  script:
    - echo "üì¶ Packaging Helm chart"
    - helm lint charts/nyx
    - helm package charts/nyx --version ${CI_COMMIT_SHORT_SHA}
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        helm package charts/nyx --version ${CI_COMMIT_TAG#v}
      fi
    - echo "‚úÖ Helm chart packaged"
  artifacts:
    expire_in: 1 month
    paths:
      - "*.tgz"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'
  tags:
    - docker

# ==================================================================================
# Staging deployment
# ==================================================================================

.deploy_base:
  image: alpine/k8s:${KUBECTL_VERSION}
  before_script:
    - apk add --no-cache helm=${HELM_VERSION}
    - kubectl version --client
    - helm version

deploy:staging:
  extends: .deploy_base
  stage: release
  environment:
    name: staging
    url: https://staging.nyx-network.local
    on_stop: cleanup:staging
  script:
    - echo "üöÄ Deploying to staging environment"
    - kubectl config use-context staging
    - kubectl create namespace ${STAGING_NAMESPACE} || true
    - |
      helm upgrade --install nyx charts/nyx \
        --namespace ${STAGING_NAMESPACE} \
        --set image.tag=${CI_COMMIT_SHORT_SHA} \
        --set image.repository=${DOCKER_REGISTRY} \
        --set environment=staging \
        --set replicas=2 \
        --wait \
        --timeout 10m
    - echo "‚úÖ Staging deployment completed"
    - kubectl get pods -n ${STAGING_NAMESPACE}
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: manual
  dependencies:
    - helm:package
    - docker:build-daemon
    - docker:build-cli
    - docker:build-http-proxy
  tags:
    - kubernetes

# Verify staging deployment
verify:staging:
  extends: .deploy_base
  stage: .post
  script:
    - echo "üîç Verifying staging deployment"
    - kubectl config use-context staging
    - |
      # Wait for pods to be ready
      kubectl wait --for=condition=ready pod \
        -l app=nyx-daemon \
        -n ${STAGING_NAMESPACE} \
        --timeout=300s
    - |
      # Check pod health
      POD_COUNT=$(kubectl get pods -n ${STAGING_NAMESPACE} -l app=nyx-daemon --field-selector=status.phase=Running -o json | jq '.items | length')
      echo "Running pods: $POD_COUNT"
      if [ "$POD_COUNT" -lt 1 ]; then
        echo "‚ùå Not enough healthy pods running"
        exit 1
      fi
    - echo "‚úÖ Staging verification passed"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: on_success
  dependencies:
    - deploy:staging
  tags:
    - kubernetes

# ==================================================================================
# Production deployment
# ==================================================================================

deploy:production:
  extends: .deploy_base
  stage: release
  environment:
    name: production
    url: https://nyx-network.local
    on_stop: cleanup:production
  script:
    - echo "üöÄ Deploying to production environment"
    - kubectl config use-context production
    - kubectl create namespace ${PRODUCTION_NAMESPACE} || true
    - |
      # Use tagged version for production
      VERSION=${CI_COMMIT_TAG#v}
      if [ -z "$VERSION" ]; then
        VERSION=${CI_COMMIT_SHORT_SHA}
      fi
    - |
      helm upgrade --install nyx charts/nyx \
        --namespace ${PRODUCTION_NAMESPACE} \
        --set image.tag=${VERSION} \
        --set image.repository=${DOCKER_REGISTRY} \
        --set environment=production \
        --set replicas=3 \
        --set resources.requests.memory=2Gi \
        --set resources.requests.cpu=1000m \
        --set resources.limits.memory=4Gi \
        --set resources.limits.cpu=2000m \
        --wait \
        --timeout 15m
    - echo "‚úÖ Production deployment completed"
    - kubectl get pods -n ${PRODUCTION_NAMESPACE}
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
      when: manual
  dependencies:
    - helm:package
    - docker:build-daemon
    - docker:build-cli
    - docker:build-http-proxy
  tags:
    - kubernetes

# Verify production deployment
verify:production:
  extends: .deploy_base
  stage: .post
  script:
    - echo "üîç Verifying production deployment"
    - kubectl config use-context production
    - |
      # Wait for pods to be ready
      kubectl wait --for=condition=ready pod \
        -l app=nyx-daemon \
        -n ${PRODUCTION_NAMESPACE} \
        --timeout=600s
    - |
      # Check pod health
      POD_COUNT=$(kubectl get pods -n ${PRODUCTION_NAMESPACE} -l app=nyx-daemon --field-selector=status.phase=Running -o json | jq '.items | length')
      echo "Running pods: $POD_COUNT"
      if [ "$POD_COUNT" -lt 2 ]; then
        echo "‚ùå Not enough healthy pods running"
        exit 1
      fi
    - |
      # Basic smoke test
      echo "Running smoke tests..."
      # Add your smoke test commands here
    - echo "‚úÖ Production verification passed"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
      when: on_success
  dependencies:
    - deploy:production
  tags:
    - kubernetes

# ==================================================================================
# Rollback capabilities
# ==================================================================================

rollback:staging:
  extends: .deploy_base
  stage: release
  environment:
    name: staging
    action: rollback
  script:
    - echo "‚è™ Rolling back staging deployment"
    - kubectl config use-context staging
    - helm rollback nyx --namespace ${STAGING_NAMESPACE}
    - echo "‚úÖ Staging rollback completed"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: manual
  tags:
    - kubernetes

rollback:production:
  extends: .deploy_base
  stage: release
  environment:
    name: production
    action: rollback
  script:
    - echo "‚è™ Rolling back production deployment"
    - kubectl config use-context production
    - helm rollback nyx --namespace ${PRODUCTION_NAMESPACE}
    - echo "‚úÖ Production rollback completed"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: manual
  tags:
    - kubernetes

# ==================================================================================
# Cleanup jobs
# ==================================================================================

cleanup:staging:
  extends: .deploy_base
  stage: release
  environment:
    name: staging
    action: stop
  script:
    - echo "üßπ Cleaning up staging environment"
    - kubectl config use-context staging
    - helm uninstall nyx --namespace ${STAGING_NAMESPACE} || true
    - kubectl delete namespace ${STAGING_NAMESPACE} || true
    - echo "‚úÖ Staging cleanup completed"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: manual
  tags:
    - kubernetes

cleanup:production:
  extends: .deploy_base
  stage: release
  environment:
    name: production
    action: stop
  script:
    - echo "üßπ Cleaning up production environment"
    - kubectl config use-context production
    - helm uninstall nyx --namespace ${PRODUCTION_NAMESPACE} || true
    - echo "‚úÖ Production cleanup completed"
  rules:
    - if: '$CI_COMMIT_TAG'
      when: manual
  tags:
    - kubernetes

# ==================================================================================
# Release notes generation
# ==================================================================================

release:notes:
  image: alpine:3.19
  stage: release
  before_script:
    - apk add --no-cache git
  script:
    - echo "üìù Generating release notes"
    - |
      cat <<EOF > RELEASE_NOTES.md
      # Release ${CI_COMMIT_TAG}
      
      **Build**: ${CI_PIPELINE_ID}
      **Commit**: ${CI_COMMIT_SHORT_SHA}
      **Date**: $(date -u +"%Y-%m-%d")
      
      ## Changes
      
      $(git log --pretty=format:"- %s (%an)" $(git describe --tags --abbrev=0 HEAD^)..HEAD)
      
      ## Docker Images
      
      - \`${DOCKER_REGISTRY}/nyx-daemon:${CI_COMMIT_TAG#v}\`
      - \`${DOCKER_REGISTRY}/nyx-cli:${CI_COMMIT_TAG#v}\`
      - \`${DOCKER_REGISTRY}/nyx-http-proxy:${CI_COMMIT_TAG#v}\`
      
      ## Helm Chart
      
      \`\`\`bash
      helm install nyx oci://${DOCKER_REGISTRY}/charts/nyx --version ${CI_COMMIT_TAG#v}
      \`\`\`
      
      ---
      *Automated release by GitLab CI/CD*
      EOF
    - cat RELEASE_NOTES.md
  artifacts:
    expire_in: never
    paths:
      - RELEASE_NOTES.md
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
  tags:
    - docker
