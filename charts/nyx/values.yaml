replicaCount: 1

image:
  repository: ghcr.io/seleniaproject/nyx-daemon
  tag: latest
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 43300
  metricsPort: 9090
  annotations: {}
  loadBalancerSourceRanges: []
  externalTrafficPolicy: Cluster
  sessionAffinity: None

serviceMonitor:
  enabled: true
  interval: 15s
  scrapeTimeout: 10s
  scheme: http
  annotations: {}
  labels: {}

podSecurity:
  seccompProfile:
    type: RuntimeDefault

securityContext:
  runAsNonRoot: true
  runAsUser: 65532
  runAsGroup: 65532
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL

resources:
  requests:
    cpu: 200m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 1Gi

probes:
  liveness:
    enabled: true
    initialDelaySeconds: 15
    periodSeconds: 20
    timeoutSeconds: 5
    failureThreshold: 3
  readiness:
    enabled: true
    type: http
    httpPath: /health
    httpPort: 9090
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 3
    failureThreshold: 3
  startup:
    enabled: true
    failureThreshold: 30
    periodSeconds: 2
    timeoutSeconds: 1

podAnnotations: {}
podLabels: {}

nodeSelector: {}
tolerations: []
affinity: {}
topologySpreadConstraints: []
priorityClassName: ""
terminationGracePeriodSeconds: 30

imagePullSecrets: []

config:
  enabled: true
  mountPath: /etc/nyx
  fileName: config.toml
  data: |
    # Nyx Daemon Configuration
    listen_port = 43300
    log_level = "info"
    
    # Enable metrics endpoint
    [metrics]
    enabled = true
    port = 9090
    path = "/metrics"
    
    # Health check endpoint
    [health]
    enabled = true
    port = 9090
    path = "/health"

secrets:
  create: false
  name: ""
  apiTokenKey: NYX_CONTROL_TOKEN
  apiTokenValue: ""

serviceAccount:
  create: false
  name: ""
  annotations: {}

extraEnv: []
extraEnvFrom: []

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: nyx.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []

networkPolicy:
  enabled: false
  allowEgressDNS: true
  allowIngressFromNamespaces: []
  additionalIngressRules: []
  additionalEgressRules: []

hpa:
  enabled: false
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 80
  enableCustomPodsMetric: false
  targetBytesPerSecond: "10k"

pdb:
  enabled: true
  minAvailable: 2

stateful:
  enabled: false

bench:
  enabled: false
  image: alpine:3.19
  imagePullPolicy: IfNotPresent
  replicas: 5  # Multiple bench pods for distributed testing
  testDurationSeconds: 60
  concurrentConnections: 10
  command: ["/bin/sh","-lc"]
  args:
    - |
      set -euo pipefail
      echo "======================================================="
      echo "NYX NETWORK DAEMON - MULTI-NODE PERFORMANCE BENCHMARK"
      echo "======================================================="
      echo "Bench Pod: $(hostname)"
      echo "Target service: ${TARGET_SERVICE}:${TARGET_PORT}"
      echo "Headless service: ${TARGET_HEADLESS}"
      echo "Metrics port: ${METRICS_PORT}"
      echo "Test duration: ${TEST_DURATION_SECONDS:-60} seconds"
      echo "Concurrent connections: ${CONCURRENT_CONNECTIONS:-10}"
      echo ""
      
      # Install required tools
      if command -v apk >/dev/null 2>&1; then
        echo "Installing performance testing tools..."
        apk add --no-cache curl wget netcat-openbsd iperf3 2>/dev/null || true
      fi
      
      # Wait for all daemon pods to be ready
      echo "== Waiting for Nyx Daemon Pods =="
      for i in {1..30}; do
        READY_PODS=$(getent hosts "${TARGET_HEADLESS}" 2>/dev/null | wc -l || echo "0")
        echo "Ready daemon pods: $READY_PODS"
        if [ "$READY_PODS" -ge 3 ]; then
          echo "✅ Sufficient pods ready for testing"
          break
        fi
        sleep 2
      done
      echo ""
      
      # Discover all daemon pod IPs
      DAEMON_IPS=$(getent hosts "${TARGET_HEADLESS}" 2>/dev/null | awk '{print $1}' | sort || echo "")
      echo "== Discovered Daemon Pods =="
      for ip in $DAEMON_IPS; do
        echo "  Daemon pod: $ip"
      done
      echo ""
      
      # Multi-node connectivity matrix test
      echo "== Multi-Node Connectivity Matrix =="
      SUCCESS_COUNT=0
      TOTAL_TESTS=0
      for daemon_ip in $DAEMON_IPS; do
        echo "Testing connectivity to daemon $daemon_ip..."
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
        if nc -vz -w 3 "$daemon_ip" "${TARGET_PORT}" 2>&1; then
          echo "  ✅ Connection successful"
          SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
        else
          echo "  ❌ Connection failed"
        fi
      done
      echo "Connectivity matrix: $SUCCESS_COUNT/$TOTAL_TESTS successful"
      echo ""
      
      # Load balancing verification
      echo "== Load Balancing Verification =="
      LB_TESTS=50
      declare -A pod_hits
      for i in $(seq 1 $LB_TESTS); do
        if command -v curl >/dev/null 2>&1; then
          # Try to get response that might include pod identity
          RESPONSE=$(curl -m 2 -s "http://${TARGET_SERVICE}:${METRICS_PORT}/health" 2>/dev/null | head -c 100 || echo "timeout")
          if [ "$RESPONSE" != "timeout" ]; then
            # For now, just count successful responses
            pod_hits["success"]=$((${pod_hits["success"]:-0} + 1))
          fi
        fi
        sleep 0.1
      done
      echo "Load balancer health checks: ${pod_hits["success"]:-0}/$LB_TESTS successful"
      echo ""
      
      # Concurrent connection stress test
      echo "== Concurrent Connection Stress Test =="
      CONCURRENT=${CONCURRENT_CONNECTIONS:-10}
      DURATION=${TEST_DURATION_SECONDS:-30}
      
      echo "Starting $CONCURRENT concurrent connections for $DURATION seconds..."
      for i in $(seq 1 $CONCURRENT); do
        (
          END_TIME=$(($(date +%s) + DURATION))
          CONN_SUCCESS=0
          CONN_TOTAL=0
          while [ $(date +%s) -lt $END_TIME ]; do
            CONN_TOTAL=$((CONN_TOTAL + 1))
            if nc -z -w 1 "${TARGET_SERVICE}" "${TARGET_PORT}" 2>/dev/null; then
              CONN_SUCCESS=$((CONN_SUCCESS + 1))
            fi
            sleep 0.1
          done
          echo "  Worker $i: $CONN_SUCCESS/$CONN_TOTAL connections successful"
        ) &
      done
      
      # Wait for all background jobs
      wait
      echo ""
      
      # Throughput test with multiple daemon pods
      echo "== Multi-Pod Throughput Test =="
      THROUGHPUT_TOTAL=0
      THROUGHPUT_TESTS=0
      for daemon_ip in $DAEMON_IPS; do
        echo "Testing throughput to daemon $daemon_ip..."
        THROUGHPUT_TESTS=$((THROUGHPUT_TESTS + 1))
        
        # Simple throughput test using nc
        START_TIME=$(date +%s.%N)
        echo "test data for throughput measurement" | nc -w 2 "$daemon_ip" "${TARGET_PORT}" >/dev/null 2>&1 || true
        END_TIME=$(date +%s.%N)
        
        if command -v bc >/dev/null 2>&1; then
          DURATION=$(echo "$END_TIME - $START_TIME" | bc 2>/dev/null || echo "1")
        else
          DURATION="1"
        fi
        
        echo "  Response time: ${DURATION}s"
        THROUGHPUT_TOTAL=$((THROUGHPUT_TOTAL + 1))
      done
      echo "Throughput test completed: $THROUGHPUT_TOTAL/$THROUGHPUT_TESTS pods responded"
      echo ""
      
      # Resource utilization check via metrics
      echo "== Resource Utilization Check =="
      for daemon_ip in $DAEMON_IPS; do
        echo "Checking metrics from daemon $daemon_ip..."
        if command -v curl >/dev/null 2>&1; then
          METRICS=$(curl -m 3 -s "http://$daemon_ip:${METRICS_PORT}/metrics" 2>/dev/null | grep -E "(cpu|memory|network)" | head -5 || echo "")
          if [ -n "$METRICS" ]; then
            echo "  Sample metrics:"
            echo "$METRICS" | sed 's/^/    /'
          else
            echo "  ⚠️  No metrics available"
          fi
        fi
      done
      echo ""
      
      # Network partition simulation
      echo "== Network Resilience Test =="
      echo "Testing service discovery resilience..."
      for i in {1..10}; do
        DISCOVERED=$(getent hosts "${TARGET_SERVICE}" 2>/dev/null | wc -l || echo "0")
        if [ "$DISCOVERED" -gt 0 ]; then
          echo "  Round $i: Service discovery OK"
        else
          echo "  Round $i: Service discovery FAILED"
        fi
        sleep 1
      done
      echo ""
      
      # Final performance summary
      echo "== MULTI-NODE PERFORMANCE SUMMARY =="
      echo "🎯 Test Configuration:"
      echo "  - Daemon pods tested: $(echo $DAEMON_IPS | wc -w)"
      echo "  - Concurrent connections: $CONCURRENT"
      echo "  - Test duration: ${DURATION}s"
      echo "  - Load balancer tests: $LB_TESTS"
      echo ""
      echo "📊 Results:"
      echo "  - Pod connectivity: $SUCCESS_COUNT/$TOTAL_TESTS"
      echo "  - Load balancing: ${pod_hits["success"]:-0}/$LB_TESTS"
      echo "  - Throughput responses: $THROUGHPUT_TOTAL/$THROUGHPUT_TESTS"
      echo ""
      
      # Performance rating
      CONNECTIVITY_RATE=$(( SUCCESS_COUNT * 100 / TOTAL_TESTS ))
      LB_RATE=$(( ${pod_hits["success"]:-0} * 100 / LB_TESTS ))
      
      if [ $CONNECTIVITY_RATE -ge 90 ] && [ $LB_RATE -ge 80 ]; then
        echo "� PERFORMANCE RATING: EXCELLENT"
        echo "✅ Multi-node deployment is production-ready!"
        echo "✅ Suitable for high-load distributed applications"
        echo "🚀 Ready for U22 Programming Contest submission!"
      elif [ $CONNECTIVITY_RATE -ge 70 ] && [ $LB_RATE -ge 60 ]; then
        echo "🥈 PERFORMANCE RATING: GOOD"
        echo "✅ Multi-node deployment is functional"
        echo "⚠️  Consider tuning for higher loads"
      else
        echo "🥉 PERFORMANCE RATING: NEEDS IMPROVEMENT"
        echo "❌ Some connectivity or load balancing issues detected"
        echo "🔧 Review network configuration and resource allocation"
      fi
      echo "======================================================="
  env: []
  resources: {}